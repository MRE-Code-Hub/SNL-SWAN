SUBROUTINE polin2(x1a,x2a,ya,m,n,x1,x2,y,dy)
IMPLICIT NONE
INTEGER m,n,NMAX,MMAX
REAL dy,x1,x2,y,x1a(m),x2a(n),ya(n,m)
PARAMETER (NMAX=100,MMAX=100) 
! C USES polint
! Given arrays x1a(1:m) and x2a(1:n) of independent variables, and an m by n array of
! function values ya(1:m,1:n), tabulated at the grid points defined by x1a and x2a; and
! given values x1 and x2 of the independent variables; this routine returns an interpolated
! function value y, and an accuracy indication dy (based only on the interpolation in the x1
! direction, however).
INTEGER j,k
REAL ymtmp(MMAX),yntmp(NMAX)
!12 do j=1,m 
!11 do k=1,n 
!yntmp(k)=ya(j,k)
!   enddo
!call polint(x2a,yntmp,n,x2,ymtmp(j),dy) 
!! Interpolate answer into temporary storenddo 12 age.
!   enddo
!call polint(x1a,ymtmp,m,x1,y,dy)
!return

do k=1,m
yntmp=0.0

 do j=1,n 
   yntmp(j)=ya(j,k)
 enddo
   do j=1,n-1
   if(x2>=x2a(j).AND.x2<(x2a(j+1))) then
     call polint(x2a(j:j+1),yntmp(j:j+1),2,x2,ymtmp(k),dy) 
     exit
   endif
   enddo
   enddo
! Interpolate answer into temporary storenddo 12 age.
 do k=1,m-1
   if(x1>=x1a(k).AND.x1<(x1a(k+1))) then
   call polint(x1a(k:k+1),ymtmp(k:k+1),2,x1,y,dy) 
   exit
   endif
   enddo

END

!*****************************************************************************************************

SUBROUTINE polint(xa,ya,n,x,y,dy)
IMPLICIT NONE
INTEGER n, NMAX
REAL dy,x,y,xa(n),ya(n)
PARAMETER (NMAX=20)
! Given arrays xa and ya, each of lenth n, and given a value x, this routine returns a
! value y, and an error estimate dy. If P(x) is the polynomial of degree N-1 such that
! P(xa_i)=ya_i, i=1...,n, then returnd value y=P9x).
INTEGER i,j,m,ns
REAL den,dif,dift,ho,hp,w,c(NMAX),d(NMAX)
ns=1
c=1
  y=ya(1)
  do i = 2,n
    if (xa(i).gt.x) then
      y=(ya(i)-ya(i-1))/(xa(i)-xa(i-1))*(x-xa(i-1))+ya(i-1) !Craig's new interp
      return
    endif
  end do
  y=ya(n)

goto 56
dif=abs(x-xa(1))
11 do i=1,n
    dift=abs(x-xa(i))
    if (dift.lt.dif) then
        ns=i
        dif=dift
    endif
    c(i)=ya(i)
    d(i)=ya(i)
  enddo
y=ya(ns)
ns=ns-1
13 do m=1,n-1
12    do i=1,n-m
        ho=xa(i)-x
        hp=xa(i+m)-x
        w=c(i+1)-d(i)
        den=ho-hp
        if (den.eq.0) pause 'failure in polint'
!         this error can occur only if 2 input xa's are (to within roundoff) identical.
        den=w/den
        d(i)=hp*den
        c(i)=ho*den
     enddo
    if (2*ns.lt.n-m) then
        dy=c(ns+1)
    else
        dy=d(ns)
        ns=ns-1
    endif
    y=y+dy
   enddo
56 return
END
